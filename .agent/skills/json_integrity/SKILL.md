# JSON Output Integrity & Self-Correction Skill

This skill ensures that every JSON file generated by the agent (e.g., scenario data, mapping exports) is syntactically perfect and schema-compliant.

## 1. Triggers
- Any task requiring the creation or modification of a `.json` file.
- API responses that involve structured data payloads.
- LLM streaming responses that need partial JSON parsing.

## 2. Mandatory Workflow
Whenever a JSON output is required, follow the **"Draft-Validate-Fix"** loop:

### Step 1: Schema-Aware Drafting
- Always start with a raw `JSON` block.
- Use strictly quoted keys and handle escaping for financial text.

### Step 2: Programmatic Validation (TIED Gatekeeper - MANDATORY)
Before saving or returning a JSON to the UI, you MUST pass it through the internal validator:
- **Core Tool**: `pkg/core/utils/json_validator.go`
- **Command**: `go test ./tests/backend/gatekeeper_test.go` (or integrated API call)
- **Goal**: This is the "Hard Guardrail". If this utility returns an error, the task is considered FAILED. You must fix the JSON until `ValidateJSON` returns `nil`.

### Step 3: Self-Correction Loop
If validation fails:
1. Read the error message (e.g., "Expected ':' at line 12").
2. **First, try `RepairJSON()`** - this auto-fixes most LLM JSON errors.
3. If repair fails, re-read the file content and apply a surgical `replace_file_content` to fix only the broken part.
4. Re-run validation.

---

## 3. "Bulletproof" Rules
1. **No Placeholders**: Never use `...` or `[rest of data]` inside a JSON file.
2. **Numeric Safety**: Use strings for very large financial numbers if precision is critical, otherwise ensure valid floats.
3. **Encoding**: Force UTF-8 encoding for multi-language evidence snippets (Chinese/English).

---

## 4. Integrated JSON Repair Libraries

The TIED platform now includes production-ready JSON repair tools integrated directly into the codebase:

### A. Go Backend: `pkg/core/utils/json_validator.go`

| Function | Library | Description |
|----------|---------|-------------|
| `ValidateJSON()` | stdlib | Schema validation against Go structs |
| `RepairJSON()` | [json-repair](https://github.com/RealAlexandreAI/json-repair) | Fix LLM JSON errors (quotes, brackets, commas) |
| `MustRepairJSON()` | json-repair | Repair with fallback to `{}` on failure |
| `ParseHJSON()` | [hjson-go](https://github.com/hjson/hjson-go) | Parse human-friendly JSON with comments |
| `ParseHJSONToStruct()` | hjson-go | Parse Hjson directly into Go struct |
| `ValidateAndRepairJSON()` | Combined | The full "Draft-Validate-Fix" loop |
| `SmartParse()` | Combined | Try JSON → Repair → Hjson in order |

**Supported Repairs (Go):**
- Missing quotes around keys: `{name: "John"}` → `{"name": "John"}`
- Single quotes: `{'key': 'value'}` → `{"key": "value"}`
- Unclosed arrays/objects: `[1, 2, 3` → `[1, 2, 3]`
- Capitalization: `TRUE, FALSE, Null` → `true, false, null`
- Trailing commas: `{"a": 1,}` → `{"a": 1}`
- Comments: `{/* comment */ "a": 1}` → `{"a": 1}`
- Markdown blocks: `` ```json {...} ``` `` → `{...}`

### B. TypeScript Frontend: `web-ui/src/lib/jsonUtils.ts`

| Function | Library | Description |
|----------|---------|-------------|
| `repairJSON()` | [jsonrepair](https://github.com/josdejong/jsonrepair) | Repair malformed JSON strings |
| `safeRepairJSON()` | jsonrepair | Repair with null fallback |
| `parseWithRepair()` | jsonrepair | Parse with auto-repair |
| `safeParseWithRepair()` | jsonrepair | Safe parse with null fallback |
| `validateJSON()` | jsonrepair | Validate and report repair status |
| `StreamingJSONAccumulator` | jsonrepair | Accumulate LLM streaming chunks |

**Usage Example (TypeScript):**
```typescript
import { parseWithRepair, StreamingJSONAccumulator } from '@/lib/jsonUtils';

// One-shot repair and parse
const data = parseWithRepair<FinancialData>("{revenue: 150000, 'currency': 'USD'}");

// Streaming LLM response
const accumulator = new StreamingJSONAccumulator<AnalysisResult>();
for await (const chunk of llmStream) {
  const { partial, isComplete } = accumulator.append(chunk);
  if (partial) updateUI(partial);
  if (isComplete) break;
}
const result = accumulator.finalize();
```

---

## 5. External Reference Libraries

The integrated tools are based on these popular GitHub projects:

| Language | Library | Stars | Use Case |
|----------|---------|-------|----------|
| **Go** | [json-repair](https://github.com/RealAlexandreAI/json-repair) | ⭐ 180+ | LLM JSON repair (Go port of Python json_repair) |
| **Go** | [hjson-go](https://github.com/hjson/hjson-go) | ⭐ 330+ | Human-friendly JSON with comments |
| **TypeScript** | [jsonrepair](https://github.com/josdejong/jsonrepair) | ⭐ 1k+ | Browser & Node.js JSON repair |
| **Python** | [json_repair](https://github.com/mangiucugna/json_repair) | ⭐ 1.5k+ | Original Python implementation |
| **Python/JS** | [partial-json-parser](https://github.com/promplate/partial-json-parser) | ⭐ 200+ | Parse incomplete JSON streams |

---

## 6. Advanced: Schema Enforcement Patterns

For production-grade enforcement beyond simple repair, consider these patterns:

### A. [BAML (Boundary AI)](https://github.com/BoundaryML/baml) - Multi-Agent DSL
- **Why**: Dedicated DSL for structured output across Gemini, GPT, Claude.
- **TIED Fit**: Python/Node research agents with automatic parsing and retries.

### B. [Instructor (Go Port)](https://github.com/liushuangls/instructor-go) - Pydantic for Go
- **Why**: Uses Go structs as "Hard Constraints" for LLM output.
- **TIED Fit**: Go calculation engine, type-safe LLM responses.

### C. [TypeChat](https://github.com/microsoft/TypeChat) - TypeScript Types as Schema
- **Why**: Uses TypeScript types to guide the model.
- **TIED Fit**: Next.js UI for complex UI state JSON.
